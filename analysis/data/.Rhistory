}
if (targetProb == 0.5) {
congruency[i] <- "none"
stim_color[i] <- colors[a]
distractor_color[i] <- colors[b]
a <- b
b <- a
} else {
if (expectation[i] == targetProb) {
congruency[i] <- "met"
stim_color[i] <- colors[colNum]
distractor_color[i] <- colors[colNum-1]
} else {
congruency[i] <- "unmet"
stim_color[i] <- colors[colNum-1]
distractor_color[i] <- colors[colNum]
}
}
}
# Apply the inverse CDF transformation to the initIntervalMs values
uniform_rvs <- runif(numberOfTrials)
initIntervalMs <- qunif(uniform_rvs, min = 150, max = 1850)
for (i in 1:length(delay)) {
if (delay[i] > 0) {
initIntervalMs[i] <- runif(1, 150, 1850 - delay[i])  # Target onset relative to start of trial
} else if (delay[i] < 0) {
initIntervalMs[i] <- runif(1, 150 - delay[i], 1850)  # Target onset relative to start of trial
}
}
data <- data.table(delay, expectation, congruency, stim_color, distractor_color, targetTimeMs = initIntervalMs)
return(data)
}
df_created_all <- create_trial_list(500, targetProb, sample(1:2, 1))
# Define function to create trial list
create_trial_list <- function(numberOfTrials, targetProb, colNum=1) {
colors <- c("red", "green")
a <- 1
b <- 2
distractorProb <- 1 - targetProb
# Creating delay
delay <- rep(c(-300, -233, -167, -100, -33, 33, 100, 167, 233, 300), length.out = numberOfTrials)
delay <- sample(delay)
# Generate expectation
expectation <- c(rep(targetProb, round(numberOfTrials * targetProb)),
rep(distractorProb, round(numberOfTrials * distractorProb)))
expectation <- sample(expectation)
# Giving color to stimulus
stim_color <- vector(length = numberOfTrials)
distractor_color <- vector(length = numberOfTrials)
congruency <- vector(length = numberOfTrials)
initIntervalMs <- runif(numberOfTrials, 150, 1850)  # Generate a list of uniform random numbers between 150 and 1850
for (i in 1:length(delay)) {
if (delay[i] > 0) {
initIntervalMs[i] <- runif(1, 150, 1850 - delay[i])  # Target onset relative to start of trial
} else if (delay[i] < 0) {
initIntervalMs[i] <- runif(1, 150 - delay[i], 1850)  # Target onset relative to start of trial
}
if (targetProb == 0.5) {
congruency[i] <- "none"
stim_color[i] <- colors[a]
distractor_color[i] <- colors[b]
a <- b
b <- a
} else {
if (expectation[i] == targetProb) {
congruency[i] <- "met"
stim_color[i] <- colors[colNum]
distractor_color[i] <- colors[colNum-1]
} else {
congruency[i] <- "unmet"
stim_color[i] <- colors[colNum-1]
distractor_color[i] <- colors[colNum]
}
}
}
# Apply the inverse CDF transformation to the initIntervalMs values
uniform_rvs <- runif(numberOfTrials)
initIntervalMs <- qunif(uniform_rvs, min = 150, max = 1850)
for (i in 1:length(delay)) {
if (delay[i] > 0) {
initIntervalMs[i] <- runif(1, 150, 1850 - delay[i])  # Target onset relative to start of trial
} else if (delay[i] < 0) {
initIntervalMs[i] <- runif(1, 150 - delay[i], 1850)  # Target onset relative to start of trial
}
}
data <- data.table(delay, expectation, congruency, stim_color, distractor_color, targetTimeMs = initIntervalMs)
return(data)
}
df_created_all <- create_trial_list(500, targetProb, sample(1:2, 1))
df_created_all <- create_trial_list(500, targetProb, sample(1:2, 1))
df_created_all <- create_trial_list(500, targetProb, sample(1:2, 1))
numberOfTrials=500
num_of_participants=20
df_all <- data.frame()
for (i in 1:num_of_participants) {
df <- create_trial_list(500, targetProb, sample(1:2, 1))
df$participant <- i
df_all <- rbind(df_all, df)
}
numberOfTrials=500
num_of_participants=20
df_all <- data.frame()
for (i in 1:num_of_participants) {
df <- create_trial_list(500, targetProb, sample(1:2, 1))
df$participant <- i
df_all <- rbind(df_all, df)
}
for (i in 1:num_of_participants) {
df <- create_trial_list(500, targetProb, sample(1:2, 1))
df$participant <- i
df_all <- rbind(df_all, df)
}
df <- create_trial_list(500, targetProb, sample(1:2, 1))
for (i in 1:num_of_participants) {
df <- create_trial_list(500, targetProb, sample(1:2, 1))
df$participant <- i
df_all <- rbind(df_all, df)
}
for (i in 1:num_of_participants) {
df <- create_trial_list(500, targetProb, sample(1:2, 1))
df$participant <- i
df_all <- rbind(df_all, df)
}
for (i in 1:num_of_participants) {
df <- create_trial_list(500, targetProb, sample(1:2, 1))
df$participant <- i
df_all <- rbind(df_all, df)
}
create_trial_list <- function(numberOfTrials, targetProb, colNum = 1) {
colors <- c("red", "green")
distractorProb <- 1 - targetProb
# Creating delay
delay <- rep(c(-300, -233, -167, -100, -33, 33, 100, 167, 233, 300), length.out = numberOfTrials)
delay <- sample(delay)
# Generate expectation
expectation <- c(rep(targetProb, round(numberOfTrials * targetProb)),
rep(distractorProb, round(numberOfTrials * distractorProb)))
expectation <- sample(expectation)
# Giving color to stimulus
stim_color <- vector(length = numberOfTrials)
distractor_color <- vector(length = numberOfTrials)
congruency <- vector(length = numberOfTrials)
initIntervalMs <- runif(numberOfTrials, 150, 1850)  # Generate a list of uniform random numbers between 150 and 1850
for (i in 1:length(delay)) {
if (delay[i] > 0) {
initIntervalMs[i] <- runif(1, 150, 1850 - delay[i])  # Target onset relative to start of trial
} else if (delay[i] < 0) {
initIntervalMs[i] <- runif(1, 150 - delay[i], 1850)  # Target onset relative to start of trial
}
if (targetProb == 0.5) {
congruency[i] <- "none"
stim_color[i] <- colors[1]
distractor_color[i] <- colors[2]
} else {
if (expectation[i] == targetProb) {
congruency[i] <- "met"
stim_color[i] <- colors[colNum]
distractor_color[i] <- colors[max(colNum - 1, 1)]
} else {
congruency[i] <- "unmet"
stim_color[i] <- colors[max(colNum - 1, 1)]
distractor_color[i] <- colors[colNum]
}
}
}
# Apply the inverse CDF transformation to the initIntervalMs values
uniform_rvs <- runif(numberOfTrials)
initIntervalMs <- qunif(uniform_rvs, min = 150, max = 1850)
for (i in 1:length(delay)) {
if (delay[i] > 0) {
initIntervalMs[i] <- runif(1, 150, 1850 - delay[i])  # Target onset relative to start of trial
} else if (delay[i] < 0) {
initIntervalMs[i] <- runif(1, 150 - delay[i], 1850)  # Target onset relative to start of trial
}
}
data <- data.table(delay, expectation, congruency, stim_color, distractor_color, targetTimeMs = initIntervalMs)
return (data)
}
df <- create_trial_list(500, targetProb, sample(1:2, 1))
for (i in 1:num_of_participants) {
df <- create_trial_list(500, targetProb, sample(1:2, 1))
df$participant <- i
df_all <- rbind(df_all, df)
}
View(df_all)
20*500
df_all <- data.frame()
numberOfTrials=500
num_of_participants=20
df_all <- data.frame()
for (i in 1:num_of_participants) {
df <- create_trial_list(500, targetProb, sample(1:2, 1))
df$participant <- i
df_all <- rbind(df_all, df)
}
# params
nsim = 100
# n observers for powerCurve
nobs_sim = c(8,10,20,30)
df_all=rbind(df_erva70,df_omer70)
#df_all=df_erva70
df_all$expectation_factor=df_all$expectation
fit.for.power = lmer(pTemporalError ~ delayS * expectation + (1  |id), data = df_all)
# check object
summary(fit.for.power)
# change coefficients for power
new_d1 = fixef(fit.for.power)[2]/2
new_d2 = fixef(fit.for.power)[3]/2
new_d3 = fixef(fit.for.power)[4]/2
fixef(fit.for.power)
# add coeffs
fixef(fit.for.power)["delayS"] <- new_d1
fixef(fit.for.power)["expectation"] <- new_d2
fixef(fit.for.power)["expectation_delay"] <- new_d3
fixed=c(fixef(fit.for.power)[1]/2,fixef(fit.for.power)[2]/2,fixef(fit.for.power)[3]/2,fixef(fit.for.power)[4]/2)
# check updated object
summary(fit.for.power)
df_created_all=df_all
View(df_all)
data_cleaner <- function(data) {
df=read.csv(data)
#df <- read.csv(paste0(data_folder, data))
df$delayS <- df$delay / 1000
df$pTemporalError <- df$perceivedTime - df$target.started
df$pTemporalErrorMs <- df$pTemporalError * 1000
df$physicalDelay <- df$distractor.started - df$target.started
df$physicalDelayMs <- df$physicalDelay * 1000
df_test <- df[df$isTrial == "testSingleStim", ]
avgError <- mean(df_test$perceivedTime - df_test$target.started)
df <- df[df$isTrial == "trial" & !is.na(df$pTemporalError), ]
df$pTemporalErrorAveraged <- df$pTemporalError - avgError
df = df[, c("delayS","pTemporalError","pTemporalErrorMs","perceivedTime", "isTrial","target_color","stim_color","distractor_color","trial_num","delay","physicalDelayMs","physicalDelay","expectation","congruency","target.started",
"pTemporalErrorAveraged","participant","rTAfterMotionTreshold","responseStarted")]
return (df)
}
df_omer=data_cleaner(data_omer_80G)
df_erva70=data_cleaner(data_Erva_70)
df_erva70$id=1
df_omer70=data_cleaner(data_omer70)
df_omer70$id=2
df_omer70=data_cleaner(data_omer70)
data_omer70="omer70_expectation_shapes_perceived_time_2023-03-27_21h43.36.152.csv"
data_Erva_70="erva07_expectation_shapes_perceived_time_2023-03-23_20h55.33.677.csv"
df_erva70=data_cleaner(data_Erva_70)
setwd("~/Omer_Repos/Internship Pascal/Expectation_Shapes_Perceived_Time_final/analysis/data")
df_erva70=data_cleaner(data_Erva_70)
df_erva70$id=1
df_omer70=data_cleaner(data_omer70)
df_omer70$id=2
df_all=rbind(df_erva70,df_omer70)
#df_all=df_erva70
df_all$expectation_factor=df_all$expectation
fit.for.power = lmer(pTemporalError ~ delayS * expectation + (1  |id), data = df_all)
# check object
summary(fit.for.power)
# change coefficients for power
new_d1 = fixef(fit.for.power)[2]/2
new_d2 = fixef(fit.for.power)[3]/2
new_d3 = fixef(fit.for.power)[4]/2
fixef(fit.for.power)
# add coeffs
fixef(fit.for.power)["delayS"] <- new_d1
fixef(fit.for.power)["expectation"] <- new_d2
fixef(fit.for.power)["expectation_delay"] <- new_d3
fixed=c(fixef(fit.for.power)[1]/2,fixef(fit.for.power)[2]/2,fixef(fit.for.power)[3]/2,fixef(fit.for.power)[4]/2)
# check updated object
summary(fit.for.power)
fit.for.power <- makeLmer(y ~ delay*expectation +(1|participant), fixef=fixed, VarCorr=0.1, sigma=1, data=df_created_all)# sigma=res,
library(lme4)
library(ggplot2)
library(simr)
fit.for.power <- makeLmer(y ~ delay*expectation +(1|participant), fixef=fixed, VarCorr=0.1, sigma=1, data=df_created_all)# sigma=res,
View(df_created_all)
fit.for.power <- makeLmer(y ~ delay*expectation +(1|participant), fixef=fixed, VarCorr=0.1, sigma=1, data=df_created_all)# sigma=res,
fit.for.power <- makeLmer(y ~ delay*expectation +(1|participant), fixef=fixed, VarCorr=0.1, sigma=1, data=df_created_all)# sigma=res,
# check updated object
summary(fit.for.power)
fixed=c(fixef(fit.for.power)[1]/2,fixef(fit.for.power)[2]/2,fixef(fit.for.power)[3]/2,fixef(fit.for.power)[4]/2)
fixed
fit.for.power <- makeLmer(y ~ delayS*expectation +(1|participant), fixef=fixed, VarCorr=0.1, sigma=1, data=df_created_all)# sigma=res,
View(df_created_all)
df_created_all$delayS=df_created_all$delay / 1000
fit.for.power <- makeLmer(y ~ delayS*expectation +(1|participant), fixef=fixed, VarCorr=0.1, sigma=1, data=df_created_all)# sigma=res,
# do sim
#sim_power  = powerSim(fit.for.power,test = fixed("distractor"), nsim=nsim)
sim_power  = powerSim(fit.for.power, test = fcompare(. ~  delayS * expectation + (1 |participant)), nsim=nsim)
sim_power
summary(sim_power)
# extend n
fit.for.power_change_n = extend(fit.for.power, along = 'participant', n=max(nobs_sim))
# check n
nrow(getData(fit.for.power))
nrow(getData(fit.for.power_change_n))
#sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fixed("distractor"), sim = fit.for.power_change_n, along="subject", breaks=nobs_sim, nsim = nsim)
sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fcompare(. ~  delayS * expectation + (1 |participant)), sim = fit.for.power_change_n, along="participant", breaks=nobs_sim, nsim = nsim)
# do sim
#sim_power  = powerSim(fit.for.power,test = fixed("distractor"), nsim=nsim)
sim_power  = powerSim(fit.for.power, test = fcompare(. ~  delayS + (1 |participant)), nsim=nsim)
sim_power
summary(sim_power)
# extend n
fit.for.power_change_n = extend(fit.for.power, along = 'participant', n=max(nobs_sim))
# check n
nrow(getData(fit.for.power))
nrow(getData(fit.for.power_change_n))
#sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fixed("distractor"), sim = fit.for.power_change_n, along="subject", breaks=nobs_sim, nsim = nsim)
sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fcompare(. ~  delayS * expectation + (1 |participant)), sim = fit.for.power_change_n, along="participant", breaks=nobs_sim, nsim = nsim)
print(sim_power_var_n)
plot(sim_power_var_n)
#sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fixed("distractor"), sim = fit.for.power_change_n, along="subject", breaks=nobs_sim, nsim = nsim)
sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fcompare(. ~  delayS  + (1 |participant)), sim = fit.for.power_change_n, along="participant", breaks=nobs_sim, nsim = nsim)
print(sim_power_var_n)
plot(sim_power_var_n)
fit.for.power <- makeLmer(y ~ delayS*expectation +(1|participant), fixef=fixed, VarCorr=0.1, sigma=1, data=df_all)# sigma=res,
# do sim
#sim_power  = powerSim(fit.for.power,test = fixed("distractor"), nsim=nsim)
sim_power  = powerSim(fit.for.power, test = fcompare(. ~  delayS + (1 |participant)), nsim=nsim)
sim_power
summary(sim_power)
# extend n
fit.for.power_change_n = extend(fit.for.power, along = 'participant', n=max(nobs_sim))
# check n
nrow(getData(fit.for.power))
nrow(getData(fit.for.power_change_n))
#sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fixed("distractor"), sim = fit.for.power_change_n, along="subject", breaks=nobs_sim, nsim = nsim)
sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fcompare(. ~  delayS  + (1 |participant)), sim = fit.for.power_change_n, along="participant", breaks=nobs_sim, nsim = nsim)
print(sim_power_var_n)
plot(sim_power_var_n)
print(sim_power_var_n)
plot(sim_power_var_n)
print(sim_power_var_n)
plot(sim_power_var_n)
fit.for.power = lmer(pTemporalError ~ delayS * expectation + (1  |id), data = df_all)
# check object
summary(fit.for.power)
# change coefficients for power
new_d1 = fixef(fit.for.power)[2]/2
new_d2 = fixef(fit.for.power)[3]/2
new_d3 = fixef(fit.for.power)[4]/2
fixef(fit.for.power)
# add coeffs
fixef(fit.for.power)["delayS"] <- new_d1
fixef(fit.for.power)["expectation"] <- new_d2
fixef(fit.for.power)["expectation_delay"] <- new_d3
fixed=c(fixef(fit.for.power)[1]/2,fixef(fit.for.power)[2]/2,fixef(fit.for.power)[3]/2,fixef(fit.for.power)[4]/2)
fixed
# check updated object
summary(fit.for.power)
df_all=df_erva70
df_all$expectation_factor=df_all$expectation
fit.for.power = lmer(pTemporalError ~ delayS * expectation + (1  |id), data = df_all)
# check object
summary(fit.for.power)
# change coefficients for power
new_d1 = fixef(fit.for.power)[2]/2
new_d2 = fixef(fit.for.power)[3]/2
new_d3 = fixef(fit.for.power)[4]/2
fixef(fit.for.power)
# add coeffs
fixef(fit.for.power)["delayS"] <- new_d1
fixef(fit.for.power)["expectation"] <- new_d2
fixef(fit.for.power)["expectation_delay"] <- new_d3
df_all=df_erva70
df_all$expectation_factor=df_all$expectation
df_all=df_erva70
df_all$expectation_factor=df_all$expectation
fit.for.power = lmer(pTemporalError ~ delayS * expectation + (1  |id), data = df_all)
fit.for.power = lmer(pTemporalError ~ delayS * expectation + (1  |id), data = df_all)
fit.for.power = lmer(pTemporalError ~ delayS * expectation_factor + (1  |id), data = df_all)
fit.for.power = lmer(pTemporalError ~ delayS * expectation + (1  |id), data = df_all)
# check object
summary(fit.for.power)
# change coefficients for power
new_d1 = fixef(fit.for.power)[2]/2
new_d2 = fixef(fit.for.power)[3]/2
new_d3 = fixef(fit.for.power)[4]/2
fixef(fit.for.power)
# add coeffs
fixef(fit.for.power)["delayS"] <- new_d1
fixef(fit.for.power)["expectation"] <- new_d2
fixef(fit.for.power)["expectation_delay"] <- new_d3
fixed=c(fixef(fit.for.power)[1]/2,fixef(fit.for.power)[2]/2,fixef(fit.for.power)[3]/2,fixef(fit.for.power)[4]/2)
fixed
# check updated object
summary(fit.for.power)
df_created_all$delayS=df_created_all$delay / 1000
fit.for.power <- makeLmer(y ~ delayS*expectation +(1|participant), fixef=fixed, VarCorr=0.1, sigma=1, data=df_all)# sigma=res,
# do sim
#sim_power  = powerSim(fit.for.power,test = fixed("distractor"), nsim=nsim)
sim_power  = powerSim(fit.for.power, test = fcompare(. ~  delayS + (1 |participant)), nsim=nsim)
sim_power
summary(sim_power)
# extend n
fit.for.power_change_n = extend(fit.for.power, along = 'participant', n=max(nobs_sim))
df_all=rbind(df_erva70,df_omer70)
#df_all=df_erva70
df_all$expectation_factor=df_all$expectation
fit.for.power = lmer(pTemporalError ~ delayS * expectation + (1  |id), data = df_all)
# check object
summary(fit.for.power)
# change coefficients for power
new_d1 = fixef(fit.for.power)[2]/2
new_d2 = fixef(fit.for.power)[3]/2
new_d3 = fixef(fit.for.power)[4]/2
fixef(fit.for.power)
# add coeffs
fixef(fit.for.power)["delayS"] <- new_d1
fixef(fit.for.power)["expectation"] <- new_d2
fixef(fit.for.power)["expectation_delay"] <- new_d3
fixed=c(fixef(fit.for.power)[1]/2,fixef(fit.for.power)[2]/2,fixef(fit.for.power)[3]/2,fixef(fit.for.power)[4]/2)
fixed
# check updated object
summary(fit.for.power)
df_created_all$delayS=df_created_all$delay / 1000
fit.for.power <- makeLmer(y ~ delayS*expectation +(1|participant), fixef=fixed, VarCorr=0.1, sigma=1, data=df_all)# sigma=res,
# do sim
#sim_power  = powerSim(fit.for.power,test = fixed("distractor"), nsim=nsim)
sim_power  = powerSim(fit.for.power, test = fcompare(. ~  delayS + (1 |participant)), nsim=nsim)
sim_power
summary(sim_power)
# extend n
fit.for.power_change_n = extend(fit.for.power, along = 'participant', n=max(nobs_sim))
# check n
nrow(getData(fit.for.power))
nrow(getData(fit.for.power_change_n))
#sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fixed("distractor"), sim = fit.for.power_change_n, along="subject", breaks=nobs_sim, nsim = nsim)
sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fcompare(. ~  delayS  + (1 |participant)), sim = fit.for.power_change_n, along="participant", breaks=nobs_sim, nsim = nsim)
print(sim_power_var_n)
plot(sim_power_var_n)
fit.for.power = lmer(pTemporalError ~ delayS * expectation + (1  |id), data = df_all)
# check object
summary(fit.for.power)
# do sim
#sim_power  = powerSim(fit.for.power,test = fixed("distractor"), nsim=nsim)
sim_power  = powerSim(fit.for.power, test = fcompare(. ~  delayS + (1 |participant)), nsim=nsim)
sim_power
summary(sim_power)
# extend n
fit.for.power_change_n = extend(fit.for.power, along = 'participant', n=max(nobs_sim))
# check n
nrow(getData(fit.for.power))
nrow(getData(fit.for.power_change_n))
#sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fixed("distractor"), sim = fit.for.power_change_n, along="subject", breaks=nobs_sim, nsim = nsim)
sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fcompare(. ~  delayS  + (1 |participant)), sim = fit.for.power_change_n, along="participant", breaks=nobs_sim, nsim = nsim)
print(sim_power_var_n)
plot(sim_power_var_n)
# do sim
#sim_power  = powerSim(fit.for.power,test = fixed("distractor"), nsim=nsim)
sim_power  = powerSim(fit.for.power, test = fcompare(y ~  delayS + (1 |participant)), nsim=nsim)
print(sim_power_var_n)
plot(sim_power_var_n)
plot(sim_power_var_n)
# do sim
#sim_power  = powerSim(fit.for.power,test = fixed("distractor"), nsim=nsim)
sim_power  = powerSim(fit.for.power, test = fcompare(. ~  delayS + (1 |participant)), nsim=nsim)
sim_power
summary(sim_power)
# extend n
fit.for.power_change_n = extend(fit.for.power, along = 'participant', n=max(nobs_sim))
# check n
nrow(getData(fit.for.power))
nrow(getData(fit.for.power_change_n))
#sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fixed("distractor"), sim = fit.for.power_change_n, along="subject", breaks=nobs_sim, nsim = nsim)
sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fcompare(. ~  delayS  + (1 |participant)), sim = fit.for.power_change_n, along="participant", breaks=nobs_sim, nsim = nsim)
print(sim_power_var_n)
# extend n
fit.for.power_change_n = extend(fit.for.power, along = 'participant', n=5))#max(nobs_sim))
# check n
nrow(getData(fit.for.power))
nrow(getData(fit.for.power_change_n))
#sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fixed("distractor"), sim = fit.for.power_change_n, along="subject", breaks=nobs_sim, nsim = nsim)
sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fcompare(. ~  delayS  + (1 |participant)), sim = fit.for.power_change_n, along="participant", breaks=nobs_sim, nsim = nsim)
# extend n
fit.for.power_change_n = extend(fit.for.power, along = 'participant', n=5)#max(nobs_sim))
# check n
nrow(getData(fit.for.power))
nrow(getData(fit.for.power_change_n))
#sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fixed("distractor"), sim = fit.for.power_change_n, along="subject", breaks=nobs_sim, nsim = nsim)
sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fcompare(. ~  delayS  + (1 |participant)), sim = fit.for.power_change_n, along="participant", breaks=nobs_sim, nsim = nsim)
print(sim_power_var_n)
plot(sim_power_var_n)
# extend n
fit.for.power_change_n = extend(fit.for.power, along = 'participant', n=max(nobs_sim))
# check n
nrow(getData(fit.for.power))
nrow(getData(fit.for.power_change_n))
#sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fixed("distractor"), sim = fit.for.power_change_n, along="subject", breaks=nobs_sim, nsim = nsim)
sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fcompare(. ~  expectation  + (1 |participant)), sim = fit.for.power_change_n, along="participant", breaks=nobs_sim, nsim = nsim)
# do sim
#sim_power  = powerSim(fit.for.power,test = fixed("distractor"), nsim=nsim)
sim_power  = powerSim(fit.for.power, test = fcompare(. ~  expectation + (1 |participant)), nsim=nsim)
sim_power
# do sim
#sim_power  = powerSim(fit.for.power,test = fixed("distractor"), nsim=nsim)
sim_power  = powerSim(fit.for.power, test = fcompare(. ~  expectation + (1 |participant)), nsim=nsim)
sim_power
summary(sim_power)
fit.for.power <- makeLmer(y ~ delayS*expectation +(1|participant), fixef=fixed, VarCorr=0.1, sigma=1, data=df_created_all)# sigma=res,
# do sim
#sim_power  = powerSim(fit.for.power,test = fixed("distractor"), nsim=nsim)
sim_power  = powerSim(fit.for.power, test = fcompare(. ~  expectation + (1 |participant)), nsim=nsim)
sim_power
summary(sim_power)
# extend n
fit.for.power_change_n = extend(fit.for.power, along = 'participant', n=max(nobs_sim))
# check n
nrow(getData(fit.for.power))
nrow(getData(fit.for.power_change_n))
#sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fixed("distractor"), sim = fit.for.power_change_n, along="subject", breaks=nobs_sim, nsim = nsim)
sim_power_var_n <- powerCurve(fit.for.power_change_n, test = fcompare(. ~  expectation  + (1 |participant)), sim = fit.for.power_change_n, along="participant", breaks=nobs_sim, nsim = nsim)
print(sim_power_var_n)
plot(sim_power_var_n)
